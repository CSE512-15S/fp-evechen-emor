<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>What Affects Learning Gains?</title>
		<style>
		
		svg {
			position: absolute;
		}
		.sidebar {
			position: absolute;
			top: 0px;
			left: 900px;
			width: 400px;
		}
		
		.sidebarLow {
			position: absolute;
			top: 330px;
			left: 900px;
			width: 400px;
		}
		
		.legend {
			position: absolute;
			top: 480px;
			left: 900px;
		}
		
		.AColor {
			width: 50px;
			height: 10px;
			background-color: #b2182b;
		}
		
		.BColor {
			width: 50px;
			height: 10px;
			background-color: #2166ac;
		}
		
		.tabletColor {
			width: 50px;
			height: 10px;
			background-color: #5aae61;
		}
		
		.paperColor {
			width: 50px;
			height: 10px;
			background-color: #762a83;
		}
		
		.titleText {
			font-size: 14pt;
            font-family: Verdana;
            color: #555555;
		}
		
		.caption {
			font-size: 10pt;
            font-family: Verdana;
			width:150;
            color: #555555;
		}

		.hidden {
			visibility: hidden;
		}
		
		.A.dot{
			fill: #b2182b;
		}
		
		.B.dot{
			fill: #2166ac;
		}
		
		.paper.dot{
			fill: #762a83;
		}
		
		.tablet.dot{
			fill: #5aae61;
		}
		
		.A.dot.unselected, .B.dot.unselected, .paper.dot.unselected, .tablet.dot.unselected {
			fill: #DDDDDD;
		}
		
		.unknown.dot{
			opacity: 0.0;
		}
		
        
        .hitArea, .noHitArea{
            fill:none;
            pointer-events: all;
        }

		
		.A.bar.selected, .B.bar.selected, .tablet.selected, .paper.selected{
			stroke-width: 2;
		}
		
		.bar.correct.unselected{
			fill: #CCCCCC;
			stroke: #CCCCCC;
			stroke-width:2;
		}
		
		.bar.incorrect.unselected{
			fill: #F0F0F0;
			stroke: #F0F0F0;
			stroke-width:2;
		}	

		.paper.correct.selected{
			fill: #762a83;
			stroke: #762a83;
		}
		
		.tablet.correct.selected{
			fill: #5aae61;
			stroke: #5aae61;
		}
		
		.paper.incorrect.selected{
			fill: #c2a5cf;
			stroke: #c2a5cf;
		}
		
		.tablet.incorrect.selected{
			fill: #d9f0d3;
			stroke: #d9f0d3;
		}

		.A.correct.selected{
			fill: #b2182b;
			stroke: #b2182b;
		}
		
		.B.correct.selected{
			fill: #2166ac;
			stroke: #2166ac;
		}
		
		.A.incorrect.selected{
			fill: #f4a582;
			stroke: #f4a582;
		}
		
		.B.incorrect.selected{
			fill: #92c5de;
			stroke: #92c5de;
		}
		
		.A.bar:hover, .B.bar:hover, .tablet.bar:hover, .paper.bar:hover{
			stroke: black;
		}

        .hitArea:hover + rect.bar{
            stroke: black;
        }
        
        .hitArea:hover{
        	fill: #EFEFEF;
        }
        
		rect.bar:hover{
			stroke: black;
		}
				
		.switch.unpressed{
			fill: #D3D3D3;
			stroke: #D3D3D3;
			stroke-width: 2;
		}
		
		.switch.pressed{
			fill: #A8A8A8;
			stroke: #494949;
			stroke-width: 2;
		}

		
		.switch.unpressed:hover{
			fill: #808080;
			stroke: #808080;
		}
		
		.buttonText{
			pointer-events:none;
			font-size: 10pt;
            font-family: Verdana, Sans-Serif;
		}
		
		.buttonHolder{
			fill: #000000:
		}
		
		.questionNumber{
            font-size: 8pt;
            font-family: Verdana, Sans-Serif;
            color: #222222;
            fill-opacity: .6;			
        }
        
		.axis{
            font-size: 10pt;
            font-family: Verdana, Sans-Serif;
            color: #CCCCCC;
            fill-opacity: .6;			
        }
		
		.axisLabel {
            font-size: 6pt;
            font-family: Verdana;
            color: #CCCCCC;
            fill-opacity: .6;			
        }
        
		.axis path,
		.axis line {
			stroke: #CCCCCC;
			fill: none;
			stroke-width: 1px;
		}
		
		.axis path.domain{
			stroke-width: 0px;
		}
		
		.zero.axis{
			stroke-dasharray: 1,2;
			stroke-width: 1px;
			stroke: #808080;
		}
		.tick {
			font-size: 8pt;
		}
		
		.scrollButton{
			fill: #887B28;
		}
		</style>
		<script src="d3.min.js"></script>
	</head>
<body>
<script>
/******************************************
 * Layout and appearance variables 
 ******************************************/
var graphHeight = 200, 
	graphWidth = 200;
var problemSelectorHeight = 100;
var margin = {top: 50, right: 50, bottom: 50, left: 50};
var width = (10*graphWidth) + (8*margin.left), 
	height = (2*graphHeight) + (3*margin.top) + 2*problemSelectorHeight;

var defaultRange = [0, graphWidth]; //for visual mapping, so should be same for all graphs?

var barWidth = 10;
var barSpacing = (barWidth*2) + 15;
var barMargin = {top: 10, right: 10, bottom: 10, left: 10};
var barStrokeWidth = 2;
var barHitVert = 10; //extra hit area padding for top or bottom
var barHitHor = 10; //extra hit area padding for left or right
var labelPadding = 20; //distance between bottom of bars and the question # labels

var allBarsSelected = true;

var buttonHeight = 20, 
	buttonWidth = 100;
	
/******************************************
 * Global(?) functions/variables - maybe put into their individual callbacks to prevent accidentally overwriting axes/scale info
 ******************************************/
 	//Holds data from CSV files
 	var conditions = [];
	var graphParams = [];
    var studentDatasetUnit2 = [];
    var studentDatasetUnit4 = [];
    var problemsDataset = [];
    
    //Default starting variables
    var CURRENT_UNIT = "2";
    var CURRENT_PREPOST= "Pre"; 
    var CURRENT_BUTTON = null;
	var CURRENT_VARIABLE = "test_type";
    var CURRENT_ROW1;
    var CURRENT_ROW2;
    var CURRENT_RANGE = 0; //0, 1, and 2 graphParams are shown, click left and right buttons to change
      
    //the main SVG
    var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)

	//y axis - should be the same for all graphs
	function addYAxis(elem, offset){
		elem.append("g")
		  .attr("class", "y axis")
		  .call(yAxis)
		.append("text")
		  .attr("transform", "rotate(-90)")
		  .attr("y", 0 - margin.left)
		  .attr("x",0 - (graphHeight / 2))
		  .attr("dy", "1.5em")
		  .style("text-anchor", "middle")
		  .text("Learning Gains");
    }
    
	var yScale = d3.scale.linear()
		.domain([-20, 20]) //default, is changed in callback
		.range([200, 0]);

	var yAxis = d3.svg.axis()
		.scale(yScale)
		.orient("left")
		.ticks(10, "")

/******************************
Buttons
******************************/

var sidebar = svg.append("g")
	.attr("class", "sidebar");

var unitButtonsSidebar = sidebar.append("g")
	.attr("transform", "translate(" + 50 + "," + 270 + ")");
var variableButtonsSidebar = sidebar.append("g")
	.attr("transform", "translate(" + 50 + "," + 340 + ")");

var buttons = [];
var buttonNames = ["Unit 2 Pre", "Unit 2 Post", "Unit 4 Pre", "Unit 4 Post"];
var shrinkConstant = 0.98;

//Change size of an unpressed button
function setUnpressedSize(){
	this.attr("class", "switch unpressed");
}

//Change size of a pressed button
function setPressedSize(){
	this.attr("class", "switch pressed");	
}
//Function that switches Unit Pre Post
function switchCondition(e){
	var pr = CURRENT_PREPOST;
	var un = CURRENT_UNIT
	
	switch(e.name){
		case buttonNames[0]:
			CURRENT_PREPOST = "Pre"
			CURRENT_UNIT = "2";
		break;
		case buttonNames[1]:
			CURRENT_PREPOST = "Post"
			CURRENT_UNIT = "2";
		break;
		case buttonNames[2]:
			CURRENT_PREPOST = "Pre"
			CURRENT_UNIT = "4";
		break;
		case buttonNames[3]:
			CURRENT_PREPOST = "Post"
			CURRENT_UNIT = "4";
		break;
	}
	if(CURRENT_PREPOST != pr || CURRENT_UNIT != un){
		for(var x = 0; x < buttonNames.length; x++){
			if (buttonNames[x] != e.name){
				buttons[buttonNames[x]].select("rect").call(setUnpressedSize);
			}
			else{
				buttons[buttonNames[x]].select("rect").call(setPressedSize);
			}
		}
		drawProblemBars();
		// reset the dot selection before drawing dots
		allBarsSelected = true;
		selectedBars = [];
		drawDots();
	}
}

function changeSchool(button, data){
	//console.log(data.row);
	d3.select(button).call(setPressedSize);
	if(data.row == 1)
		CURRENT_ROW1 = d3.select(button);
	else
		CURRENT_ROW2 = d3.select(button);
	
	
	d3.selectAll(schoolButtons).each(function(d, i){
		if((this.data()[0].school != data.school || this.data()[0].period != data.period) && this.data()[0].row == data.row){
			this.attr("class", "switch unpressed"); //Dont know why the d3.select method didn't work...
		}
	})
		// reset the dot selection before drawing dots
		allBarsSelected = true;
		selectedBars = [];
		drawDots();
}

schoolButtons = [];

//Make buttons for schools, 2 rows. Do this once
function drawSchoolButtons(){
	
	//Group headers
	for(var x = 0; x < 2; x++){
		sidebar.append("text")
			.attr("class", "titleText")
			.attr("transform", "translate(900," + (buttonHeight + x*buttonHeight*6) + ")")
			.text("Select class for row " + (x+1));
	}
	
	d3.csv("students_new2.csv", function(data){ //needed?
			var groups = d3.nest()
			 .key(function(d) { return d.School; })
			 .key(function(d) { return d["Class Period"]; })
			 .entries(data);
			 
			d3.selectAll(groups)
				.each(function(d2, j){ //For each School
					d3.selectAll(this.values).each(function(dat, k){ //For each Class Period
							for(x = 0; x < 2; x++){
							var temp = sidebar.append("g")
								.attr("class", "buttonHolder")
								.attr("transform", "translate(900, " + (1.5*buttonHeight + (x*buttonHeight*6)) + ")");
							temp.append("rect")
								.data([{row: (x+1), school: this.values[k].School, period:this.values[k]["Class Period"], condition: this.values[k].Condition }])
								.attr("class", "switch unpressed")
								.attr("width", buttonWidth*2)
								.attr("height", buttonHeight)
								.attr("transform", "translate(" + (2*(buttonWidth+10) * j) + "," + (2 + buttonHeight) * k + ")")
								.on("click", function(d){changeSchool(this, d);});
							temp.append("text")
								.attr("class", "buttonText")
								.attr("transform", "translate(" + (2*(buttonWidth+10) * j) + "," + (buttonHeight*0.8 + (buttonHeight * k)) + ")")
								.text(this.values[k].School + " " + this.values[k]["Class Period"] + "-" + this.values[k].Condition);
							schoolButtons.push(temp.select("rect"));
						}
					})
				})	
		CURRENT_ROW1 = schoolButtons[0];
		CURRENT_ROW1.attr("class", "switch pressed");
		CURRENT_ROW2 = schoolButtons[3];	
		CURRENT_ROW2.attr("class", "switch pressed");			 
	})
}

drawSchoolButtons();

//Make buttons to switch between Unit, Pre-Post (4 conditions total)
for(var x = 0; x < buttonNames.length; x++){

		var dy = x <= 1 ? 0 : 1;
		var temp  = unitButtonsSidebar.append("g")
		.attr("class", "buttonHolder")
		.attr("transform", "translate(" + (900+110*(x%2)) + "," + 1.5*buttonHeight*dy + ")");

		var n = buttonNames[x];
		temp.append("rect")
			.data([{name: n}])
			.attr("class", "switch unpressed")
			.attr("width", buttonWidth)
			.attr("height", buttonHeight)
			.on("click", function(e){switchCondition(e);});
		
		temp.append("text")
			.attr("class", "buttonText")
			.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
			.text(buttonNames[x]);

		buttons[n] = temp;
}

buttons[buttonNames[0]].select("rect").attr("class", "switch pressed");

function doScroll(direction){
	var temp = CURRENT_RANGE;
	if(direction == "left"){
		if(CURRENT_RANGE > 0)
			CURRENT_RANGE -= 3;
	}
	else{
		if(CURRENT_RANGE + 3 < graphParams.length)
			CURRENT_RANGE += 3;
	}
	if(temp!= CURRENT_RANGE)
		drawDots();
}

//buttons to "scroll" graph display
var moveRight = svg.append("g")
		.append("polygon")
		.attr("class", "scrollButton")
		.attr("points", "0,0 25,25, 0,50")
		.attr("transform", "translate(940, " + (2*graphHeight + 2*margin.top - 10) + ")")
		.on("click", function(d){doScroll("right")});
		
var moveLeft = svg.append("g")
		.append("polygon")
		.attr("class", "scrollButton")
		.attr("points", "0,0 -25,25 0,50")
		.attr("transform", "translate(930, " + (2*graphHeight + 2*margin.top - 10) + ")")
		.on("click", function(d){doScroll("left")}); 

// Switch variable buttons
var testTypeButton;
var conditionButton;

// Function that switches variable
function switchVariable(e){
	var changed = false;
	if (e.name == "test_type" && CURRENT_VARIABLE != "test_type") {
		CURRENT_VARIABLE = "test_type";
		conditionButton.select("rect").call(setUnpressedSize);
		testTypeButton.select("rect").call(setPressedSize);
		
		/*
		//this is ugly, I'm sorry
		d3.select("#selectAllAButton").select("text")
				.attr("transform", "translate(" + buttonWidth/3 + "," + buttonHeight/1.5 + ")")
				.text("All A");
		d3.select("#deselectAllAButton").select("text")
				.attr("transform", "translate(" + ((buttonWidth/3)) + "," + buttonHeight/1.5 + ")")
				.text("No A");
		d3.select("#selectAllBButton").select("text")
				.attr("transform", "translate(" + buttonWidth/3 + "," + buttonHeight/1.5 + ")")
				.text("All B");
		d3.select("#deselectAllBButton").select("text")
				.attr("transform", "translate(" + ((buttonWidth/3)) + "," + buttonHeight/1.5 + ")")
				.text("No B");
		*/		
		changed = true;
	}
	else if (e.name == "condition" && CURRENT_VARIABLE != "condition") {
		CURRENT_VARIABLE = "condition";
		testTypeButton.select("rect").call(setUnpressedSize);
		conditionButton.select("rect").call(setPressedSize);


		/*
		//this is ugly too, I'm sorry
		d3.select("#selectAllAButton").select("text")
				.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
				.text("All Tablet");
		d3.select("#deselectAllAButton").select("text")
				.attr("transform", "translate(" + ((buttonWidth/5)) + "," + buttonHeight/1.5 + ")")
				.text("No Tablet");
		d3.select("#selectAllBButton").select("text")
				.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
				.text("All Paper");
		d3.select("#deselectAllBButton").select("text")
				.attr("transform", "translate(" + ((buttonWidth/5)) + "," + buttonHeight/1.5 + ")")
				.text("No Paper");
		*/		
		changed = true;
	}
	
	if (changed) {
		 drawProblemBars();
		// reset the dot selection before drawing dots
		allBarsSelected = true;
		selectedBars = [];
		drawDots();
	}
}

// Make buttons to switch between "test type" and "condition"
testTypeButton = variableButtonsSidebar.append("g")
	.attr("class", "buttonHolder")
	.attr("transform", "translate(" + 900 + "," + (1.5*buttonHeight*3) + ")");
testTypeButton.append("rect")
	.data([{name: "test_type"}])
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(e){switchVariable(e);});
testTypeButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
	.text("Test Type");
testTypeButton.select("rect").attr("class", "switch pressed");

/*conditionButton = variableButtonsSidebar.append("g")
	.attr("class", "buttonHolder")
	.attr("transform", "translate(" + (900+110) + "," + (1.5*buttonHeight*3) + ")");
conditionButton.append("rect")
	.data([{name: "condition"}])
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(e){switchVariable(e);});
conditionButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
	.text("Condition");
*/

/******************************
 * Map student data to graphs
 ******************************/	
function drawDots(){
	//Alter the range for Y axis
	
	var currentDataSet = studentDatasetUnit2;
	if(CURRENT_UNIT == 4)
		currentDataSet = studentDatasetUnit4;
	
	var min = d3.min(currentDataSet, function(d) { return +d["Learning Gain"];})
	var max = d3.max(currentDataSet, function(d) { return +d["Learning Gain"];})
	var yDottedOffset = Math.abs(max - min) * 0.1;
	yScale.domain([min-yDottedOffset, max]); //TODO make min like 10% less than actual min or something
	
	
	var currentShown = graphParams.slice(CURRENT_RANGE,CURRENT_RANGE+3);
	
	d3.selectAll(currentShown)
		.each(function(d, i) {
		for(var z = 1; z <= 2; z++){
				//Current Graph Holder
				var holder = svg.select(".graph" + i + ".graphHolder.row" + z);
				holder.selectAll(".axis").remove();
			
				//X Scale and Axis
				//TODO nonstatic offset for domain, based on actual data domain, maybe 10%?
				min = d3.min(currentDataSet, function(d) { return +d[currentShown[i]];})
				max = d3.max(currentDataSet, function(d) { return +d[currentShown[i]];})
				var xDottedOffset = Math.abs(max - min) * 0.1;
			
				var xScale = d3.scale.linear()
						.domain([min-xDottedOffset, max])
						//.clamp(true) //needed?
						.range(defaultRange);
								
				//X Axis
				var xAxis = d3.svg.axis()
						.scale(xScale)
						.orient("bottom")
						.ticks(5, "");
			
				holder.append("g")
						.attr("class", "x axis")
						.attr("transform", "translate(0," + graphHeight + ")")
						.call(xAxis)
					  .append("text")
						  .attr("transform", "translate(" + (graphWidth / 2) + " ," + (margin.bottom-15) + ")")
						  .style("text-anchor", "middle")
						  .text(currentShown[i]);
			
				//Y Axis
				addYAxis(holder, yDottedOffset);
					
				//Dotted lines intersecting at 0
				//Vertical Line
				holder.append("line")
						.attr("class", currentShown[i] + " zero axis")
						.attr("x1", xScale(0))
						.attr("y1", 0)
						.attr("x2", xScale(0))
						.attr("y2", graphHeight)
			
				//Horizontal Line
				holder.append("line")
						.attr("class", currentShown[i] + " zero axis")
						.attr("x1", 0)
						.attr("y1", yScale(0))
						.attr("x2", graphWidth)
						.attr("y2", yScale(0));
										
				//Redraw/Draw dots					
				var dots = holder.selectAll("circle")
					.data(currentDataSet);
													
				dots.enter().append("circle")
					.attr("cy", 0)
					.attr("cx", 0)
					.attr("r", 1.5);
			
				dots.attr("class", function(d) {
								
								/*var t = d["Unit " + CURRENT_UNIT + " Pre-Test Type"].toUpperCase();
								if(CURRENT_PREPOST == "Post"){
									if(t == "A")
										t = "B";
									else if(t == "B")
										t = "A";
									else
										t = "unknown";
								}
								if (t == "")
									t = "unknown";
								*/
								var t = "B";
								var sc = CURRENT_ROW1.data()[0].school;
								var per = CURRENT_ROW1.data()[0].period;
								var row = CURRENT_ROW1.data()[0].row;
						
								if(z == 2){
									sc = CURRENT_ROW2.data()[0].school;
									per = CURRENT_ROW2.data()[0].period;
									row = CURRENT_ROW2.data()[0].row;						
								}
								var inSelection = ((sc == d["School"] && per == d["Class Period"]));								
								var dotSelection = "selected";
								if (!allBarsSelected) {
									dotSelection = setDotSelection(d, t);
								}
								/*if((t == "A" || t == "B") && inSelection)
									return t + " dot " + dotSelection;
								else*/
								if(inSelection)
									return "B dot " + dotSelection;
								else
									return "unknown dot " + dotSelection;
						})
					.attr("transform", function(d) { 
								var gains = d["Learning Gain"];
								var cat = +d[currentShown[i]];
			
								if(isNaN(gains) || isNaN(cat))
									return "translate(0,0)";
								else
									return "translate(" + xScale(cat) + "," + yScale(+gains) + ")";
							})
					.attr("opacity", function(d){ 
						var gains = d["Learning Gain"];
						var cat = +d[currentShown[i]];
						return (isNaN(gains) || isNaN(cat)) ? 0.0 : 1.0;
					})

				dots.exit()
					.remove();
		}
	});
}

function setDotSelection(dotData, dotType) {	
	var selected = false;
	
	for(var i = 0; i < selectedBars.length; i++) {
		var barData = selectedBars[i];
		dotType = dotType[0];
		if (dotType == barData.test_type) {
			var key;
			if (CURRENT_UNIT == 2 && CURRENT_PREPOST == "Pre") {
				key = "Unit2_Pre_" + barData.question;
			}
			else if (CURRENT_UNIT == 2 && CURRENT_PREPOST == "Post") {
				key = "Unit2_Post_" + barData.question;
			}
			else if (CURRENT_UNIT == 4 && CURRENT_PREPOST == "Pre") {
				key = "Unit4_Pre_" + barData.question;
			}
			else if (CURRENT_UNIT == 4 && CURRENT_PREPOST == "Post") {
				key = "Unit4_Post_" + barData.question;
			}
			var answer = dotData[key];
			if ((barData.correctness == "correct" && answer == 1) || (barData.correctness == "incorrect" && answer == 0)) {
				selected = true;
			}			
		}		
	}
	
	if (selected) {
		return "selected";
	}
	else {
		return "unselected";
	}
}


// version that does not nest by condition
function drawGraphs() {
	d3.csv("students_new2.csv", function(data){
		
		//Assign loaded data to variables
		studentDatasetUnit2 = data.map(function(d){return d;});
		graphParams = d3.keys(data[0]).slice(17, 26); //only select the parameters we want to make graphs for 

		d3.selectAll(graphParams.slice(0,3))
			.each(function(d, i) {	
				for(var x = 1; x <= 2; x++){
					// Create the graph container
					var colNum = i;
					var rowNum = 0;
					if (x == 2) {
						rowNum = 1;
					}
				
					var holderX = margin.left + colNum*(graphWidth+2*margin.left);
					var holderY = (rowNum * (graphHeight + margin.top)) + margin.top/2;
					var holder = svg.append("g")
						.attr("class", " graph" + i + " graphHolder row" + x)
						.attr("width", graphWidth)
						.attr("height", graphHeight)
						.attr("transform", "translate(" + holderX + "," + holderY + ")");				
				}	

			});
		
		drawDots();
	});
	
	d3.csv("students_new4.csv", function(data){
		
		//Assign loaded data to variables
		studentDatasetUnit4 = data.map(function(d){return d;});
	});
}

//initial loading
drawGraphs();

/********************************
Map problem correctness data to bottom bar
********************************/
//Container
var barsholderX = margin.left;
var barsholderY = (2*graphHeight) + (3*margin.top);
var barsholder = svg.append("g")
	.attr("class", "barsHolder")
	.attr("width", width)
	.attr("height", problemSelectorHeight)
	.attr("transform", "translate(" + barsholderX + "," + barsholderY + ")");
	
   //TODO alter the range based on actual learning gains range?
var barsY = d3.scale.linear()
	.domain([0, 1])
	.clamp(1)
	.range([100 + (barStrokeWidth/2), 0]); 

var barsYAxis = d3.svg.axis()
	.scale(barsY)
	.orient("left")
	.ticks(2, "%");	
	
//Y Axis, percentage
barsholder.append("g")
	  .attr("class", "axis")
	  .call(barsYAxis)
	.append("text")
	  .attr("transform", "rotate(-90)")
	  .attr("y", 0 - margin.left)
	  .attr("x",0 - (problemSelectorHeight / 2))
	  .attr("dy", "0.8em")
	  .style("text-anchor", "middle")
	  .text("% Correct");

//"Question #" text
barsholder.append("text")
	  .attr("class", "axisLabel")
	  .attr("y", problemSelectorHeight + 2*barHitVert)
	  .attr("x", 0 - 50)
	  .text("QUESTION");

//Holders for question numbers 
barsholder.append("g")
   .attr("class", "questionNumberHolder")
   .attr("width", width)
   .attr("height", problemSelectorHeight/4)

	  
//TODO clean this part up a bit? forloop + array for class names, maybe
//Holders for correct bars
barsholder.append("g")
   .attr("class", "correctBarsA oneBarTypeHolder")
   .attr("width", width)
   .attr("height", problemSelectorHeight)

barsholder.append("g")
   .attr("class", "correctBarsB oneBarTypeHolder")
   .attr("width", width)
   .attr("height", problemSelectorHeight)
   
//Holders for incorrect bars
barsholder.append("g")
   .attr("class", "incorrectBarsA oneBarTypeHolder")
   .attr("width", width)
   .attr("height", problemSelectorHeight)

barsholder.append("g")
   .attr("class", "incorrectBarsB oneBarTypeHolder")
   .attr("width", width)
   .attr("height", problemSelectorHeight)

// Add the "Select All" and "Deselect All" buttons
var selectAllButton = svg.append("g")
	.attr("class", "buttonHolder")
	.attr("transform", "translate(" + 1120 + "," + barsholderY + ")");
selectAllButton.append("rect")
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(){selectAll();});
selectAllButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + buttonWidth/5 + "," + buttonHeight/1.5 + ")")
	.text("Select All");

var deselectAllButton = svg.append("g")
	.attr("class", "buttonHolder")
	.attr("transform", "translate(" + 1120 + "," + (barsholderY + 1.3*buttonHeight) + ")");
deselectAllButton.append("rect")
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(){deselectAll();});
deselectAllButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + ((buttonWidth/5)-10) + "," + buttonHeight/1.5 + ")")
	.text("Deselect All");
/*
var selectAllAButton = svg.append("g")
	.attr("id", "selectAllAButton")
	.attr("class", "buttonHolder")
	.attr("transform", "translate(" + 1120 + "," + barsholderY + ")");
selectAllAButton.append("rect")
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(){selectAll("A");});
selectAllAButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + buttonWidth/3 + "," + buttonHeight/1.5 + ")")
	.text("All A");

var deselectAllAButton = svg.append("g")
	.attr("id", "deselectAllAButton")
	.attr("class", "buttonHolder")
	.attr("transform", "translate(" + 1120 + "," + (barsholderY + 1.3*buttonHeight) + ")");
deselectAllAButton.append("rect")
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(){deselectAll("A");});
deselectAllAButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + ((buttonWidth/3)) + "," + buttonHeight/1.5 + ")")
	.text("No A");
	
var selectAllBButton = svg.append("g")
	.attr("class", "buttonHolder")
	.attr("id", "selectAllBButton")
	.attr("transform", "translate(" + 1120 + "," + (barsholderY + 3*buttonHeight) + ")");
selectAllBButton.append("rect")
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(){selectAll("B");});
selectAllBButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + buttonWidth/3 + "," + buttonHeight/1.5 + ")")
	.text("All B");

var deselectAllBButton = svg.append("g")
	.attr("id", "deselectAllBButton")
	.attr("class", "buttonHolder")
	.attr("transform", "translate(" + 1120 + "," + (barsholderY + 4.2*buttonHeight) + ")");
deselectAllBButton.append("rect")
	.attr("class", "switch unpressed")
	.attr("width", buttonWidth)
	.attr("height", buttonHeight)
	.on("click", function(){deselectAll("B");});
deselectAllBButton.append("text")
	.attr("class", "buttonText")
	.attr("transform", "translate(" + ((buttonWidth/3)) + "," + buttonHeight/1.5 + ")")
	.text("No B");
*/

// Object to hold information about the currently selected bars (only used when not all bars are selected)
var selectedBars = [];

/*
function selectAll(type) {
	allBarsSelected = true;
	var t = type;
	if(CURRENT_VARIABLE == "condition")
		t = (type == "A")  ? "tablet" : "paper";
			
	d3.selectAll("." + t + ".bar")
		.each(function(){
			var bar_class = this.getAttribute("class");
			var endIndex = bar_class.indexOf("bar") + 4; 
			var new_class = bar_class.substring(0,endIndex) + "selected";
			this.setAttribute("class", new_class);
		});
	selectedBars = [];
	drawDots();
}

function deselectAll(type) {
	allBarsSelected = false;
	var t = type;
	if(CURRENT_VARIABLE == "condition")
		t = (type == "A")  ? "tablet" : "paper";
		
	d3.selectAll("." + t + ".bar")
		.each(function(){
			var bar_class = this.getAttribute("class");
			var endIndex = bar_class.indexOf("bar") + 4; 
			var new_class = bar_class.substring(0,endIndex) + "unselected";
			this.setAttribute("class", new_class);
		});
	selectedBars = [];
	drawDots();
}
*/

function selectAll() {
	allBarsSelected = true;
	
	d3.selectAll(".bar")
		.each(function(){
			var bar_class = this.getAttribute("class");
			var endIndex = bar_class.indexOf("bar") + 4; 
			var new_class = bar_class.substring(0,endIndex) + "selected";
			this.setAttribute("class", new_class);
		});
	selectedBars = [];
	drawDots();
}

function deselectAll() {
	allBarsSelected = false;

		
	d3.selectAll(".bar")
		.each(function(){
			var bar_class = this.getAttribute("class");
			var endIndex = bar_class.indexOf("bar") + 4; 
			var new_class = bar_class.substring(0,endIndex) + "unselected";
			this.setAttribute("class", new_class);
		});
	selectedBars = [];
	drawDots();
}

function onBarClick(bar_object) {
	if (allBarsSelected) {
		deselectAll();
		allBarsSelected = false;
	}
	
	var bar_class = bar_object.getAttribute("class");
	var new_class = bar_class.replace(/unselected/g, 'selected');
	bar_object.setAttribute("class", new_class);
	
	// store information about the newly selected bar in the selectedBars data structure
	var t = new_class[0];
	var c = "correct";
	if (new_class.indexOf("incorrect") > 0) {
		c = "incorrect";
	}
	var i = bar_object.getAttribute("id");
	i = i.substring(7);
	q = i[0];
	if (q != "4") {
		q = q + "." + i.substring(1);
	}
	
	//console.log("appended question: " + q + " type: " + t + " correctness: " + c);
	selectedBars.push({question:q, test_type:t, correctness:c});
	drawDots();
}
	   
//TODO separate out drawing the gridlines and the bars like I did for the dots
function drawProblemBars(){
	var problemsFile = "problems2.csv";
	if (CURRENT_VARIABLE == "condition") {
		problemsFile = "problems_condition.csv";
	}
	
	d3.csv(problemsFile, function(data){
		problemsDataset = data.map(function(d){return d;});
	
		// When you select a new unit and test, we want all the bars to start out selected
		allBarsSelected = true;

		//TODO create a wrapper for each bar that is its mouseover area
		//.data([{selected: false}]) to store info about whether it is pressed or not
		//add interactivity to bars 

		//Nest by Unit or Condition
		if (CURRENT_VARIABLE == "condition") {
			var groups = d3.nest()
				 .key(function(d) { return d.Unit; })
				 .key(function(d) { return d.Condition; })
				 .entries(data);
		}
		else{
			var groups = d3.nest()
			 .key(function(d) { return d.Unit; })
			 .key(function(d) { return d.Type; })
			 .entries(data);
		}
	
		//Select all rows of current unit
		d3.selectAll(groups)
			.each(function(d2, k){ 
				if(this.key == CURRENT_UNIT){
					//Map A and B separately for 4 groups of bars: A-correct, A-incorrect, B-correct, B-incorrect 
					d3.selectAll(this.values)
						.each(function(dat, j){

							//simplify selection for pre/post
							var corr = CURRENT_PREPOST + " Correct";
							var incorr = CURRENT_PREPOST + " Incorrect";
							
							var tail = (this.key == "A") ? "A" : "B";
							var style_var = tail;
							
							//Map tablet/paper to A/B so we don't have to create entirely new bar holders
							if(CURRENT_VARIABLE == "condition"){
								tail = (this.key == "tablet") ? "A" : "B";
								style_var =  (this.key == "tablet") ? "tablet" : "paper";
							}
							
							barsholder.select(".correctBars" + tail)
									.selectAll("g")
									.remove();
							
							var correctBars = barsholder.select(".correctBars" + tail)
									.selectAll("g")
									.data(this.values);
																									
							correctBars.enter().append("g");
						
							//must draw hitArea before actual bar for CSS next sibling selector to work            
							 correctBars
							 	.append("rect")
							 	.data(this.values)
							 		.attr("class", function(d){
							 			if(+d[corr] == 0) return "noHitArea";
							 			else return "hitArea"
							 		})
							 		.attr("x", function(d, i) { return (-1*barHitHor + j*barHitHor) + (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
							 		.attr("y", function(d){ return barsY(+d[corr]/(+d[corr]+(+d[incorr])));})
							 		.attr("width", barWidth + barHitHor)
							 		.attr("height", function(d) {
							 			if(+d[incorr] == 0)
							 				return problemSelectorHeight + (barStrokeWidth/2);
							 			else
							 				return barHitVert + Math.max(0,problemSelectorHeight - barsY(+d[corr]/(+d[corr]+(+d[incorr])))); 
							 		})                                     
									.on("click", function(){onBarClick(this.parentNode.lastChild);}); //this is kind of hacky, but works for now bc we know exact structure of this part of the DOM
							correctBars
								.append("rect")
									.data(this.values)
									.attr("class", style_var + " correct bar selected")
									.attr("id", function(d) { return ("problem" + d["Question"]).replace(/\./g,"");})
									.attr("x", function(d, i) { return (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
									.attr("width", barWidth)
									.attr("y", function(d){ return barStrokeWidth/2 + barsY(+d[corr]/(+d[corr]+(+d[incorr])));})
									.attr("height", function(d) {
										if(+d[incorr] == 0)
											return problemSelectorHeight + (barStrokeWidth/2);
										else
											return Math.max(0, problemSelectorHeight - barsY(+d[corr]/(+d[corr]+(+d[incorr])))); 
									})
									.on("click", function(){onBarClick(this);});
							
							correctBars.exit().remove();
							
							barsholder.select(".incorrectBars" + tail)
									.selectAll("g")
									.remove();

							var incorrectBars = barsholder.select(".incorrectBars" + tail)
									.selectAll("g")
									.data(this.values);			
							incorrectBars.enter().append("g")
						
							//must draw hitArea before actual bar for CSS next sibling selector to work            
							 incorrectBars
							 	.append("rect")
							 	.data(this.values)
							 		.attr("class", " hitArea")
							 		.attr("x", function(d, i) { return (-1*barHitHor + j*barHitHor) + (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
							 		.attr("y", -1*barHitVert)
							 		.attr("width", barWidth + barHitHor)
							 		.attr("height", function(d) {
							 				if(+d[corr] == 0)
							 					return barHitVert + problemSelectorHeight + (barStrokeWidth/2);
							 				else
							 					return barHitVert + Math.max(0, problemSelectorHeight - barsY(+d[incorr]/(+d[corr]+(+d[incorr])))); 
							 		})
							 		.on("click", function(){onBarClick(this.parentNode.lastChild);});                                     
						
							incorrectBars
								.append("rect")
									.data(this.values)
									.attr("class", style_var + " incorrect bar selected")
									.attr("id", function(d) { return ("problem" + d["Question"]).replace(/\./g,"");})
									.attr("x", function(d, i) { return (j*(barStrokeWidth + barWidth))+i*(barSpacing); })
									.attr("width", barWidth)
									.attr("y", 0)
									.attr("height", function(d) { 
							 				if(+d[corr] == 0)
							 					return problemSelectorHeight + (barStrokeWidth/2); 
							 				else
							 					return Math.max(0, problemSelectorHeight - barsY(+d[incorr]/(+d[corr]+(+d[incorr])))); 
									})
									.on("click", function(){onBarClick(this);});
							
							incorrectBars.exit().remove();	
							
							//Question Text
							barsholder.select(".questionNumberHolder")
									.selectAll("g")
									.remove();

							var qHolder = barsholder.select(".questionNumberHolder")
									.selectAll("g")
									.data(this.values);			
							qHolder.enter().append("g")
							
							qHolder.append("g")
								.append("text")
								  .attr("class", "questionNumber")
								  .attr("y", problemSelectorHeight + 2*barHitVert)
								  .attr("x", function(d, i) { 
								  		if(d["Question"].length == 1)
								  			return i*(barSpacing)+5; //HACKY
								  		else
								  			return i*(barSpacing); 
								  	})
								  .text(function(d) { return (d["Question"]).replace(/\./g,"");});
								  
							qHolder.exit().remove();	
					   });
				}
			});		
	});
}
drawProblemBars();


</script>

</body>
</html>
