<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Real Time Student Data Visualization</title>
		<style>
		
			/*Timeline Slider*/
			 .axis {
			   font: 10px sans-serif;
			   -webkit-user-select: none;
			   -moz-user-select: none;
			   user-select: none;
			 }

			 .axis .domain {
			   fill: none;
			   stroke: #000;
			   stroke-opacity: .3;
			   stroke-width: 10px;
			   stroke-linecap: round;
			 }


			 .axis .halo {
			   fill: none;
			   stroke: #ddd;
			   stroke-width: 8px;
			   stroke-linecap: round;
			 }

			 .slider .handle {
			   fill: #fff;
			   stroke: #000;
			   stroke-opacity: .5;
			   stroke-width: 1.25px;
			   cursor: crosshair;
			 }
			 
			/*Concept Tree*/
		   .link {
			 fill: none;
			 stroke: RGB(128,128,128);
			 stroke-width: 10;
			 opacity : 0.5;
		   }

		   .border {
			 fill: none;
			 shape-rendering: crispEdges;
			 stroke: #aaa;
		   }

		   .nodeVisual {
		   	fill: none;
			 /*stroke: #fff;
			 fill: gray;
			 opacity: 0.2;*/
		   }
		   
		   .conceptTitle{
		   	font-weight: bold;
		   }
		   
		   .student_name, .marker, .info_overlay{
		 	  pointer-events:none
		   }
		
			.student_bg {
				stroke-width: 1px;
				stroke: #777777;
			}
		
		   .student_bg .unselected{

		   }
		   
		   .student_bg .selected{

		   }
		   
		   .overlay{
		   		fill: gray;
		   		opacity: 0.2;
		   }
		   
		   rect.info_overlay {
		   		stroke-width: 1;
		   		stroke: black;
		   }
		   
		   text.concept_name{
		   		font-size: 8;
		   }
		   
		   text{
		   		font-family: Verdana, Sans-Serif;
		   		-webkit-user-select: none;
		   }
		</style>
		<link rel="stylesheet" href="d3.slider.css" />  
		<script src="d3.min.js"></script>
	</head>
<body>
<script>
/**********************************************
Global Variables
***********************************************/
//JSON objects
var BY_STUDENT //is this necessary? maybe for the less real time version
var CONCEPTS = [];
var CONCEPT_LABELS = [];
var BY_CONCEPT = {}; //for the more realtime version
var SVG;

var CLASS_START = null; //slider start. Assuming that all classes happen in the same calendar day
var CLASS_END = null; //slider end

var TIMELINE; //the slider for time
var SLIDER; 
var BRUSH;
var TIME_SCALE;

var width = 1500;
	height = 2000;
	
var lineHeight = 20; //height of each student line
var conceptTitleHeight = 16; // height of the concept title	
var markerWidth = 10; //width of each check/cross

var CORRECTNESS_REDGREEN = d3.scale.quantize()
		.domain([0, 1])
		.range(["#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b","#a6d96a","#66bd63"]);
		
var CORRECTNESS_ORANGEBLUE = d3.scale.quantize()
		.domain([0, 1])
		.range(["#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e0f3f8","#abd9e9","#74add1"]);

var check_mark = 'M 197.67968,534.31563 C 197.40468,534.31208 196.21788,532.53719 195.04234,530.37143 L 192.905,526.43368 L 193.45901,525.87968 C 193.76371,525.57497 194.58269,525.32567 195.27896,525.32567 L 196.5449,525.32567 L 197.18129,527.33076 L 197.81768,529.33584 L 202.88215,523.79451 C 205.66761,520.74678 208.88522,517.75085 210.03239,517.13691 L 212.11815,516.02064 L 207.90871,520.80282 C 205.59351,523.43302 202.45735,527.55085 200.93947,529.95355 C 199.42159,532.35625 197.95468,534.31919 197.67968,534.31563 z'
/**********************************************
Loading/Setup
***********************************************/
d3.json("data_files/short_sessions/students_4.json", function(data){
			BY_STUDENT = data; 
			reshapeStudentData();
            drawTimeline();	
			//loadConcepts();
			drawStudentList();
			drawTree();
});

function reshapeStudentData(){
    for (student in BY_STUDENT) {
        
        var name = BY_STUDENT[student].name;
        
        for (group in BY_STUDENT[student].concepts){
        
            var start = new Date(BY_STUDENT[student].concepts[group].start * 1000);
            var end = new Date(BY_STUDENT[student].concepts[group].end * 1000);
              
             if(CLASS_START == null){
                CLASS_START = start;
                CLASS_END =  end;
             }
             else {
                CLASS_START = CLASS_START > start ? start : CLASS_START;
                CLASS_END = CLASS_END < end ? end : CLASS_END;
             }
              
              if(!BY_CONCEPT[group]){
                          BY_CONCEPT[group] = {};
                          CONCEPTS.push(group);
            	}
            BY_CONCEPT[group][student] = {name: name};
            BY_CONCEPT[group][student]["start"] = start;
            BY_CONCEPT[group][student]["end"] = end;
            BY_CONCEPT[group][student]["problems"] = BY_STUDENT[student].concepts[group]["problems"];
        }
    }

	// re-order concepts and clean up concept names
	for (i in CONCEPTS) {
		concept = CONCEPTS[i]
		concept = concept.charAt(0).toUpperCase() + concept.slice(1);
		concept = concept.charAt(0) + concept.charAt(1).toUpperCase() + concept.slice(2);
		problem = concept.slice(5);
		concept = concept.slice(0,5);
		
		if (problem[0] == "e") {
			problem = "Exercise Problem " + problem.slice(1);
		}
		else if (problem[0] == "w") {
			problem = "Workbook Problem " + problem.slice(1);
		}
		
		CONCEPT_LABELS[i] = concept + " " + problem
	}
	CONCEPTS.sort()
	CONCEPT_LABELS.sort
	console.log("CONCEPTS: ", CONCEPTS)
	console.log("CONCEPT_LABELS: ", CONCEPT_LABELS)
	
	
	
    
    console.log(CLASS_START + " " + CLASS_END);
}
	
SVG = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)


//Timeline
function drawTimeline()
{
    var formatDate = d3.time.format("%X");
	var margin = {top: 200, right: 50, bottom: 200, left: 50},
		width = 600,
		height = 500 - margin.bottom - margin.top;
	
	TIME_SCALE = d3.time.scale()
		.domain([CLASS_START, CLASS_END]) //TODO this should be the min and max time from the students data
		.range([0, width]) 
		.clamp(true);

	BRUSH = d3.svg.brush()
		.x(TIME_SCALE)
		.extent([CLASS_START, CLASS_START])
		.on("brush", brushed);

	//Timeline holder
	var t = SVG.append("g")
		.attr("id", "timelineHolder")
		.attr("transform", "translate(100, 0)");
	
	//Add axis
	t.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + height / 2 + ")")
		.call(d3.svg.axis()
		  .scale(TIME_SCALE)
		  .orient("bottom")
		  .tickFormat(function(d) { return formatDate(d); })
		  .tickSize(0)
		  .tickPadding(12))
	  .select(".domain")
	  //.select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
		.attr("class", "halo");

	SLIDER = t.append("g")
		.attr("class", "slider")
		.call(BRUSH);
	
	//Wonder what this does?
	SLIDER.selectAll(".extent,.resize")
		.remove();

	SLIDER.select(".background")
		.attr("height", height);

	var handle = SLIDER.append("circle")
		.attr("class", "handle")
		.attr("transform", "translate(0," + height / 2 + ")")
		.attr("r", 9);

	// slider
// 		.call(brush.event)
// 	  .transition() // gratuitous intro!
// 		.duration(750)
// 		.call(brush.extent([70, 70]))
// 		.call(brush.event);
	
	//what happens when you drag the slider?
	function brushed() {
	  var value = BRUSH.extent()[0];

	  if (d3.event.sourceEvent) { // not a programmatic event
		value = TIME_SCALE.invert(d3.mouse(this)[0]); //invert maps mouse coordinate (y) back to slider coordinate (x)
		BRUSH.extent([value, value]);
	  }
        
	  handle.attr("cx", TIME_SCALE(value)); //location of center of handle
      updateTree();
      updateStudentList();
	}
}

// Grouping students into concepts - for loop or for-in?
// //make an array per concept, based on concepts JSON
// for (student : BY_STUDENT) {
// 	for(group : student.values.concepts){
// 		for (problem  : group){
// 			//check timestamp
// 			//if timestamp is within current time selection, add to appropriate array
// 		}
// }
// //take all arrays and redraw the concepts
/********************************
LIST VIEW - Alphabetical list of students - May be duplicating effort of some things done in other section, but will leave like this for now
*********************************/
var STUDENT_LIST_HOLDER;

function drawStudentList(){

	var margin = {top: 100, right: 0, bottom: 100, left: 0},
		width = 600,
		height =  2000;


		STUDENT_LIST_HOLDER = SVG.append("g")
			.attr("width", width)
			.attr("height", height)
			.append("g")
			.attr("transform", "translate(700," + 2*margin.top + ")");
		
		updateStudentList();
}

var CURRENT_SELECTION = null; //currently selected student

function updateStudentList(){	

	STUDENT_LIST_HOLDER.selectAll(".studentHolder").remove();

		var j = 0;
        Object.keys(BY_STUDENT).forEach(function(student){
        	var oneStudent = STUDENT_LIST_HOLDER.append("g")
        	   .data(student) 
			   .attr("class", "studentHolder")
			   .attr("height", lineHeight)
			   .attr("transform", "translate(0," + j * 5 + ")");
			
        	var numShown = 0;
            var numCorrect = 0;
            
            var conceptCount = 0;
            
            var bg =  oneStudent.append("rect");
            		  
            var overlay = oneStudent.append("rect")
            		  .attr("class", "overlay")
            		  .style("visibility", "hidden");
              		  
        	 Object.keys(BY_STUDENT[student].concepts).forEach(function(concept){
        	//for(var concept in BY_STUDENT[student].concepts){
        		var numShownThisRound = 0;
           		 var numCorrectThisRound = 0;
        	
				for(var x = 0; x < BY_STUDENT[student].concepts[concept].problems.length; x++){
                    //markers for correct/incorrect problems
                    oneStudent.append("text")
                            .attr("x", function(d){  return 100 + markerWidth * (numShown + conceptCount);})
                            .attr("y", function(d){  return lineHeight*(j+1);})
                            .attr("width", markerWidth)
                            .attr("class", "marker")
                            .text(function(d){
                                if(new Date(BY_STUDENT[student].concepts[concept].problems[x].timestamp*1000) <= BRUSH.extent()[0]){
                                	numShown++;
                                	numShownThisRound++;
                                    if(BY_STUDENT[student].concepts[concept].problems[x].correctness == "correct"){
                                    	numCorrect++;
                                    	numCorrectThisRound++;
                                        return "O";
                                    }
                                    else
                                        return "X";
                                }
                                else{
                                    this.remove();
                                    return "";
                                }
                            });          
                }
                if(BY_STUDENT[student].concepts[concept].problems.length > 0 && numShownThisRound > 0){ //how to only show concepts actually shown??
                
                //bars for correctness per section - maybe creating it here is overkill and should be done upon clicking the student?
                oneStudent.append("rect")
                	.attr("class", "info_overlay")
                	.attr("width", function(){
						return markerWidth * (numShownThisRound);
					})
					.attr("height", "5px")
					.attr("x", 100 + markerWidth * (conceptCount + numShown - numShownThisRound))
					.attr("y", function(d){  return  lineHeight*(j) - 6})
					.style("visibility", "hidden")
					.style("fill", function(d){
						if(isNaN(numCorrectThisRound/numShownThisRound))
							return "grey";
						else
							return CORRECTNESS_REDGREEN(numCorrectThisRound/numShownThisRound);
		   			});
		   		//similarly, label for the concept
		   		oneStudent.append("text")
		   			.attr("class", "concept_name info_overlay")
		   			.attr("transform", "translate(" + (100 + (markerWidth * (conceptCount + numShown - 0.5 * numShownThisRound))) + "," + (lineHeight*(j) - 6) + "), rotate(-60)")
		   			.style("visibility", "hidden")
		   			.text(concept);
		   		 
		   			conceptCount++;
		   		}
        	});

		
		oneStudent.append("text")
		   .attr("x", function(d){  return 5;})
		   .attr("class", "student_name")
		   .attr("y", function(d){  return conceptTitleHeight + (lineHeight*j) + 4;})
		   .text(function(){return BY_STUDENT[student].name;}); 
		
		   
		bg.attr("width", function(){
				return 100 + markerWidth * (numShown + conceptCount);
			})
			//.data(function(){return [{elem: bg, data: BY_STUDENT[student]}]})
			.attr("height", "20px")
			.attr("x", 0)
			.attr("y", function(){  return lineHeight*(j) + 4})
			.attr("class", "student_bg")
			.style("fill", function(){
				if(isNaN(numCorrect/numShown))
					return "grey";
				else
					return CORRECTNESS_REDGREEN(numCorrect/numShown);
		   	})
		   	.on("click", function(){ 
		   		studentClicked(this);
		   	});
		   	
		   overlay.attr("width", bg.attr("width"))
		   		  .attr("height", 20)
		   		  .attr("x", 0)
		   		  .attr("y", bg.attr("y"))
		   		  .on("click", function(){ 
		   				studentClicked("deselect"); //just want to deselect everything. Note this is super hacky bc clicking "anywhere" will not dismiss the selection, only on a student line
		  		 	});;
		j++;    
                    
        });
}

function studentClicked(source){
	//console.log("click!");
	if(CURRENT_SELECTION == null && source != "deselect"){ //nothing currently selected
		CURRENT_SELECTION = source.parentNode; //the student holder group
		
		//hide all
		STUDENT_LIST_HOLDER.selectAll(".student_bg").attr("class", "student_bg unselected").style("visibility", "hidden");
		STUDENT_LIST_HOLDER.selectAll("text").style("opacity", 0.05);
		STUDENT_LIST_HOLDER.selectAll(".overlay").style("visibility", "visible"); //TODO each node must have an overlay with transparency for whited/grayed out effect
		
		//show selected
		d3.select(CURRENT_SELECTION).select(".student_bg").attr("class", "student_bg selected").style("visibility", "visible");
		d3.select(CURRENT_SELECTION).selectAll("text").style("opacity", 1);
		d3.select(CURRENT_SELECTION).select(".overlay").style("visibility", "hidden");	
		d3.select(CURRENT_SELECTION).selectAll(".info_overlay").style("visibility", "visible");	
	}
	else { //deselect everything if something is selected, unless you tapped on the current selection
		STUDENT_LIST_HOLDER.selectAll(".student_bg").attr("class", "student_bg").style("visibility", "visible");
		STUDENT_LIST_HOLDER.selectAll("text").style("opacity", 1);
		STUDENT_LIST_HOLDER.selectAll(".overlay").style("visibility", "hidden");
		STUDENT_LIST_HOLDER.selectAll(".info_overlay").style("visibility", "hidden");	
		CURRENT_SELECTION = null;
	}
}
/********************************
"TREE" VIEW
*********************************/

/*function loadConcepts(){
d3.json("concepts.json", function(data){
			CONCEPTS_JSON = data;
            drawTree();
	});
}
*/
var nodeWidth = 200,
	nodeHeight = 100;

var TREE_HOLDER;
var TREE_MAIN;
var TREE_NODES;
var TREE_LINKS;

function drawTree(){ //aka update tree; remember animations for shrinking and growing and moving nodes

	var margin = {top: 100, right: 0, bottom: 100, left: 0},
		width =600,
		height =  1000;

	TREE_HOLDER = SVG.append("g")
			.attr("width", width + margin.left + margin.right)
			.attr("height", 2000)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + 2*margin.top + ")");

	/*var size= [width, height];

    // Compute the layout.
    TREE_MAIN = d3.layout.tree().size(size),
        TREE_NODES = TREE_MAIN.nodes(CONCEPTS_JSON),
        TREE_LINKS = TREE_MAIN.links(TREE_NODES);
    
    console.log(BRUSH.extent()[0]);*/
    updateTree();
	
}
function updateTree(){
    //which students are at which node?
    
    // Create the link lines.
    /*TREE_HOLDER.selectAll(".link")
        .data(TREE_LINKS)
		.enter()
		.append("path")
        .attr("class", "link")
        .attr("d", connector);*/
	
	
	//TODO separate this so that the text can get appended too...
	var nodes = TREE_HOLDER.selectAll(".node")
        .data(CONCEPTS);

		nodes.enter().append("g") //height and y set later
			.attr("class", "node")
            .append("rect")
            .attr("class", "nodeVisual")
			.attr("width", nodeWidth)
			.attr("x", function(d){  return 100;})

		var prevY = 0;
        nodes.each(function(d, i){
        
            var j = 0.5;
            
            //removing old elements - necessary?
            d3.select(this).selectAll(".studentHolder").remove(); 
            d3.select(this).selectAll(".student_bg").remove();
            d3.select(this).selectAll(".conceptTitle").remove();
                    
	        //name of state
	        d3.select(this).append("text")
	        	.attr("class", "conceptTitle")
	        	.attr("x", function(){  return 100;})
			  	.attr("y", function(){  return prevY;})
	        	.text(function(d){return d;});
            
            for(student in BY_CONCEPT[d]){
                if( BRUSH.extent()[0] > BY_CONCEPT[d][student].start &&
                    BRUSH.extent()[0] < BY_CONCEPT[d][student].end){
                    var grp = d3.select(this).append("g")
                                .attr("class", "studentHolder")
                                .attr("transform", "translate(0," + j * 5 + ")");
                    
                    //calculating bg width and color
                    var numShown = 0;
                    var numCorrect = 0;
                    for(var x = 0; x < BY_CONCEPT[d][student].problems.length; x++){
                        if(new Date(BY_CONCEPT[d][student].problems[x].timestamp*1000) <= BRUSH.extent()[0]){
                        	numShown++;
                        	if(BY_CONCEPT[d][student].problems[x].correctness == "correct")
                        		numCorrect++;
                        }
                    }
                    
                    grp.append("rect")
                        .attr("width", function(){
                        	return 110 + markerWidth*numShown + "px";
                        })
   						.attr("height", "20px")
                        .attr("x", function(){  return 100;})
                        .attr("y", function(){  return prevY + (lineHeight*j);})
                    	.attr("class", "student_bg")
					    .attr("fill", function(){
						return CORRECTNESS_REDGREEN(numCorrect/numShown);
					});
					
                    var markers = grp.selectAll("text")
                            .data(BY_CONCEPT[d][student].problems);
                    
                    //markers for correct/incorrect problems
                    markers.enter().append("text")
                    		.attr("class", "marker")
                    		.attr("width", markerWidth)
                            .attr("x", function(d, i){  return 200 + (markerWidth * i);})
                            .attr("y", function(){  return prevY + conceptTitleHeight + ((lineHeight)*(j));})
                            .text(function(d){
                                if(new Date(d.timestamp*1000) <= BRUSH.extent()[0]){
                                    if(d.correctness == "correct")
                                        return "O";
                                    else
                                        return "X";
                                }
                                else{
                                    this.remove();
                                    return "";
                                }
                            });                    
                    markers.exit().remove();

                    //student name
                     grp.append("text")
                     		.attr("class", "student_name")
                            .attr("x", function(){  return 105;})
                            .attr("y", function(){  return prevY + conceptTitleHeight + ((lineHeight)*(j));})
                            .text(function(){return BY_CONCEPT[d][student].name;});                   
                    j++;
                 }
            }
			
			
            
            //position and size containing rect appropriately
            d3.select(this).select(".nodeVisual")
            	.attr("height", 25*j)
            	.attr("y", function(d, i){  return prevY;});
            prevY = prevY + 25*(j) + 50;           
            
        });
        
        
        nodes.exit().remove();
}

function connector(d, i){
    return     "M" + 90 + "," + d.source.y
             + "C 70," + d.source.y  //control point 1
             + " 70," + d.target.y //control point 2
        	 + " 90," + d.target.y; // target
}
		 
</script>

</body>
</html>