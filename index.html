<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Real Time Student Data Visualization</title>
		<style>
		
			/*Timeline Slider*/
			 .axis {
			   font: 10px sans-serif;
			   -webkit-user-select: none;
			   -moz-user-select: none;
			   user-select: none;
			 }

			 .axis .domain {
			   fill: none;
			   stroke: #000;
			   stroke-opacity: .3;
			   stroke-width: 10px;
			   stroke-linecap: round;
			 }


			 .axis .halo {
			   fill: none;
			   stroke: #ddd;
			   stroke-width: 8px;
			   stroke-linecap: round;
			 }

			 .slider .handle {
			   fill: #fff;
			   stroke: #000;
			   stroke-opacity: .5;
			   stroke-width: 1.25px;
			   cursor: crosshair;
			 }
			 
			/*Concept Tree*/
		   .link {
			 fill: none;
			 stroke: RGB(128,128,128);
			 stroke-width: 10;
			 opacity : 0.5;
		   }

		   .border {
			 fill: none;
			 shape-rendering: crispEdges;
			 stroke: #aaa;
		   }

		   .nodeVisual {
			 stroke: #fff;
			 fill: gray;
			 opacity: 0.2;
		   }
		   
		   .conceptTitle{
		   	font-weight: bold;
		   }
		   
		   .student_name, .marker, .overlay{
		 	  pointer-events:none
		   }
		   
		   .student_bg .unselected{

		   }
		   
		   .student_bg .selected{

		   }
		   
		   .overlay{
		   		fill: gray;
		   		opacity: 0.3;
		   }
		   
		</style>
		<link rel="stylesheet" href="d3.slider.css" />  
		<script src="d3.min.js"></script>
	</head>
<body>
<script>
/**********************************************
Global Variables
***********************************************/
//JSON objects
var BY_STUDENT //is this necessary? maybe for the less real time version
var CONCEPTS_JSON;
var BY_CONCEPT = {}; //for the more realtime version
var SVG;

var CLASS_START = null; //slider start. Assuming that all classes happen in the same calendar day
var CLASS_END = null; //slider end

var TIMELINE; //the slider for time
var SLIDER; 
var BRUSH;
var TIME_SCALE;

var width = 2000;
	height = 1000;
	
var lineHeight = 20; //height of each student line	

var CORRECTNESS_REDGREEN = d3.scale.quantize()
		.domain([0, 1])
		.range(["#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b","#a6d96a","#66bd63"]);
		
var CORRECTNESS_ORANGEBLUE = d3.scale.quantize()
		.domain([0, 1])
		.range(["#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e0f3f8","#abd9e9","#74add1"]);

/**********************************************
Loading/Setup
***********************************************/
d3.json("studentsnell.json", function(data){
			BY_STUDENT = data; 
			reshapeStudentData();
            drawTimeline();	
			loadConcepts();
			drawStudentList();
});

function reshapeStudentData(){
    for (student in BY_STUDENT) {
        
        var name = BY_STUDENT[student].name;
        
        for (group in BY_STUDENT[student].concepts){
        
            var start = new Date(BY_STUDENT[student].concepts[group].start * 1000);
            var end = new Date(BY_STUDENT[student].concepts[group].end * 1000);
              
             if(CLASS_START == null){
                CLASS_START = start;
                CLASS_END =  end;
             }
             else {
                CLASS_START = CLASS_START > start ? start : CLASS_START;
                CLASS_END = CLASS_END < end ? end : CLASS_END;
             }
              
              if(!BY_CONCEPT[group])
                          BY_CONCEPT[group] = {};
            BY_CONCEPT[group][student] = {name: name};
            BY_CONCEPT[group][student]["start"] = start;
            BY_CONCEPT[group][student]["end"] = end;
            BY_CONCEPT[group][student]["problems"] = BY_STUDENT[student].concepts[group]["problems"];
        }
    }
    
    console.log(CLASS_START + " " + CLASS_END);
}
	
SVG = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)


//Timeline
function drawTimeline()
{
    var formatDate = d3.time.format("%X");
	var margin = {top: 200, right: 50, bottom: 200, left: 50},
		width = 600,
		height = 500 - margin.bottom - margin.top;
	
	TIME_SCALE = d3.time.scale()
		.domain([CLASS_START, CLASS_END]) //TODO this should be the min and max time from the students data
		.range([0, width]) 
		.clamp(true);

	BRUSH = d3.svg.brush()
		.x(TIME_SCALE)
		.extent([CLASS_START, CLASS_START])
		.on("brush", brushed);

	//Timeline holder
	var t = SVG.append("g")
		.attr("id", "timelineHolder")
		.attr("transform", "translate(100, 0)");
	
	//Add axis
	t.append("g")
		.attr("class", "x axis")
		.attr("transform", "translate(0," + height / 2 + ")")
		.call(d3.svg.axis()
		  .scale(TIME_SCALE)
		  .orient("bottom")
		  .tickFormat(function(d) { return formatDate(d); })
		  .tickSize(0)
		  .tickPadding(12))
	  .select(".domain")
	  //.select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
		.attr("class", "halo");

	SLIDER = t.append("g")
		.attr("class", "slider")
		.call(BRUSH);
	
	//Wonder what this does?
	SLIDER.selectAll(".extent,.resize")
		.remove();

	SLIDER.select(".background")
		.attr("height", height);

	var handle = SLIDER.append("circle")
		.attr("class", "handle")
		.attr("transform", "translate(0," + height / 2 + ")")
		.attr("r", 9);

	// slider
// 		.call(brush.event)
// 	  .transition() // gratuitous intro!
// 		.duration(750)
// 		.call(brush.extent([70, 70]))
// 		.call(brush.event);
	
	//what happens when you drag the slider?
	function brushed() {
	  var value = BRUSH.extent()[0];

	  if (d3.event.sourceEvent) { // not a programmatic event
		value = TIME_SCALE.invert(d3.mouse(this)[0]); //invert maps mouse coordinate (y) back to slider coordinate (x)
		BRUSH.extent([value, value]);
	  }
        
	  handle.attr("cx", TIME_SCALE(value)); //location of center of handle
      updateTree();
      updateStudentList();
	}
}

// Grouping students into concepts - for loop or for-in?
// //make an array per concept, based on concepts JSON
// for (student : BY_STUDENT) {
// 	for(group : student.values.concepts){
// 		for (problem  : group){
// 			//check timestamp
// 			//if timestamp is within current time selection, add to appropriate array
// 		}
// }
// //take all arrays and redraw the concepts
/********************************
LIST VIEW - Alphabetical list of students - May be duplicating effort of some things done in other section, but will leave like this for now
*********************************/
var STUDENT_LIST_HOLDER;

function drawStudentList(){

	var margin = {top: 100, right: 0, bottom: 100, left: 0},
		width =600,
		height =  1000;


		STUDENT_LIST_HOLDER = SVG.append("g")
			.attr("width", width)
			.attr("height", height)
			.append("g")
			.attr("transform", "translate(700," + margin.top + ")");
		
		updateStudentList();
}

var CURRENT_SELECTION = null; //currently selected student

function updateStudentList(){	

	STUDENT_LIST_HOLDER.selectAll(".studentHolder").remove();

		var j = 0;
        for(var student in BY_STUDENT){
        	var oneStudent = STUDENT_LIST_HOLDER.append("g")
        	   .data(student) 
			   .attr("class", "studentHolder")
			   .attr("height", lineHeight);
			
        	var numShown = 0;
            var numCorrect = 0;
            var conceptCount = 0;
            var atLeastOne = false;
            
            var bg =  oneStudent.append("rect");
            		  
            var overlay = oneStudent.append("rect")
            		  .attr("class", "overlay")
            		  .style("visibility", "hidden");
            		  		  
        	for(var concept in BY_STUDENT[student].concepts){
				for(var x = 0; x < BY_STUDENT[student].concepts[concept].problems.length; x++){
                    //markers for correct/incorrect problems
                    oneStudent.append("text")
                            .attr("x", function(d){  return 100 + lineHeight * (numShown + conceptCount);})
                            .attr("y", function(d){  return lineHeight*(j+1);})
                            .attr("class", "marker")
                            .text(function(d){
                                if(new Date(BY_STUDENT[student].concepts[concept].problems[x].timestamp*1000) <= BRUSH.extent()[0]){
                                	atLeastOne = true;
                                	numShown++;
                                    if(BY_STUDENT[student].concepts[concept].problems[x].correctness == "correct"){
                                    	numCorrect++;
                                        return "O";
                                    }
                                    else
                                        return "X";
                                }
                                else{
                                    this.remove();
                                    return "";
                                }
                            });          
                }
                if(BY_STUDENT[student].concepts[concept].problems.length > 0 && atLeastOne){ //how to only show concepts actually shown??
                	conceptCount++;
                	!atLeastOne;
                }    
        	}

		
		oneStudent.append("text")
		   .attr("x", function(d){  return 0;})
		   .attr("class", "student_name")
		   .attr("y", function(d){  return lineHeight*(j+1);})
		   .text(function(){return BY_STUDENT[student].name;}); 
		   
		bg.attr("width", function(){
				return 100 + lineHeight * (numShown + conceptCount);
			})
			.data([{elem: bg, data: BY_STUDENT[student]}])
			.attr("height", "20px")
			.attr("x", 0)
			.attr("y", function(d){  return  lineHeight*(j)})
			.attr("class", "student_bg")
			.attr("fill", function(d){
				if(isNaN(numCorrect/numShown))
					return "grey";
				else
					return CORRECTNESS_REDGREEN(numCorrect/numShown);
		   	})
		   	.on("click", function(d){ 
		   		studentClicked(d);
		   	});
		   	
		   overlay.attr("width", bg.attr("width"))
		   		  .attr("height", 20)
		   		  .attr("x", 0)
		   		  .attr("y", bg.attr("y"));
		j++;    
                    
        };
}

function studentClicked(d){
	console.log("click!");
	console.log(CURRENT_SELECTION);
	if(CURRENT_SELECTION == null){ //nothing currently selected
		CURRENT_SELECTION = d.elem.node().parentNode; //the student holder group
		
		//hide all
		STUDENT_LIST_HOLDER.selectAll(".student_bg").attr("class", "student_bg unselected").style("visibility", "hidden");
		STUDENT_LIST_HOLDER.selectAll("text").style("opacity", 0.3);
		STUDENT_LIST_HOLDER.selectAll(".overlay").style("visibility", "visible"); //TODO each node must have an overlay with transparency for whited/grayed out effect
		
		//show selected
		d3.select(CURRENT_SELECTION).select(".student_bg").attr("class", "student_bg selected").style("visibility", "visible");
		d3.select(CURRENT_SELECTION).selectAll("text").style("opacity", 1);
		d3.select(CURRENT_SELECTION).select(".overlay").style("visibility", "hidden");	
	}
	else { //deselect everything if something is selected, unless you tapped on the current selection
		STUDENT_LIST_HOLDER.selectAll(".student_bg").attr("class", "student_bg").style("visibility", "visible");
		STUDENT_LIST_HOLDER.selectAll("text").style("opacity", 1);
		STUDENT_LIST_HOLDER.selectAll(".overlay").style("visibility", "hidden");
		CURRENT_SELECTION = null;
	}
	console.log(CURRENT_SELECTION);
}
/********************************
TREE VIEW
*********************************/

function loadConcepts(){
d3.json("concepts.json", function(data){
			CONCEPTS_JSON = data;
            drawTree();
	});
}

var nodeWidth = 200,
	nodeHeight = 100;

var TREE_HOLDER;
var TREE_MAIN;
var TREE_NODES;
var TREE_LINKS;

function drawTree(){ //aka update tree; remember animations for shrinking and growing and moving nodes

	var margin = {top: 100, right: 0, bottom: 100, left: 0},
		width =600,
		height =  1000;

	TREE_HOLDER = SVG.append("g")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	var size= [width, height];

    // Compute the layout.
    TREE_MAIN = d3.layout.tree().size(size),
        TREE_NODES = TREE_MAIN.nodes(CONCEPTS_JSON),
        TREE_LINKS = TREE_MAIN.links(TREE_NODES);
    
    console.log(BRUSH.extent()[0]);
    updateTree();
	
}
function updateTree(){
    //which students are at which node?
    
    // Create the link lines.
    /*TREE_HOLDER.selectAll(".link")
        .data(TREE_LINKS)
		.enter()
		.append("path")
        .attr("class", "link")
        .attr("d", connector);*/
	
	//TODO separate this so that the text can get appended too...
	var nodes = TREE_HOLDER.selectAll(".node")
        .data(TREE_NODES);
        
		nodes.enter().append("g") //height and y set later
			.attr("class", "node")
            .append("rect")
            .attr("class", "nodeVisual")
			.attr("width", nodeWidth)
			.attr("x", function(d){  return 100;})

		var prevY = 0;
        nodes.each(function(d, i){
            var j = 0;
            
            //removing old elements - necessary?
            d3.select(this).selectAll(".studentHolder").remove(); 
            d3.select(this).selectAll(".student_bg").remove();
            d3.select(this).selectAll(".conceptTitle").remove();
                    
        //name of state
        d3.select(this).append("text")
        	.attr("class", "conceptTitle")
        	.attr("x", function(d){  return 100;})
		  	.attr("y", function(d, i){  return prevY;})
        	.text(function(d){return d.concept;});
            
            for(student in BY_CONCEPT[d.concept]){
                if( BRUSH.extent()[0] > BY_CONCEPT[d.concept][student].start &&
                    BRUSH.extent()[0] < BY_CONCEPT[d.concept][student].end){
                    var grp = d3.select(this).append("g")
                                .attr("class", "studentHolder");
                    
                    //calculating bg width and color
                    var numShown = 0;
                    var numCorrect = 0;
                    for(var x = 0; x < BY_CONCEPT[d.concept][student].problems.length; x++){
                        if(new Date(BY_CONCEPT[d.concept][student].problems[x].timestamp*1000) <= BRUSH.extent()[0]){
                        	numShown++;
                        	if(BY_CONCEPT[d.concept][student].problems[x].correctness == "correct")
                        		numCorrect++;
                        }
                    }
                    
                    grp.append("rect")
                        .attr("width", function(){
                        	return 100 + 20*numShown + "px";
                        })
   						.attr("height", "20px")
                        .attr("x", function(d){  return 100;})
                        .attr("y", function(d){  return prevY + (lineHeight*j);})
                    	.attr("class", "student_bg")
					    .attr("fill", function(d){
						return CORRECTNESS_REDGREEN(numCorrect/numShown);
					});
					
                    var markers = grp.selectAll("text")
                            .data(BY_CONCEPT[d.concept][student].problems);
                    
                    //markers for correct/incorrect problems
                    markers.enter().append("text")
                    		.attr("class", "marker")
                            .attr("x", function(d, i){  return 200 + (lineHeight * i);})
                            .attr("y", function(d){  return prevY + (lineHeight*(j+1));})
                            .text(function(d){
                                if(new Date(d.timestamp*1000) <= BRUSH.extent()[0]){
                                    if(d.correctness == "correct")
                                        return "O";
                                    else
                                        return "X";
                                }
                                else{
                                    this.remove();
                                    return "";
                                }
                            });                    
                    markers.exit().remove();
                    
                    //student name
                     grp.append("text")
                     		.attr("class", "student_name")
                            .attr("x", function(d){  return 100;})
                            .attr("y", function(d){  return prevY + (lineHeight*(j+1));})
                            .text(function(){return BY_CONCEPT[d.concept][student].name;});                   
                    j++;
                 }
            }
            
            //position and size containing rect appropriately
            d3.select(this).select(".nodeVisual")
            	.attr("height", 20*j)
            	.attr("y", function(d, i){  return prevY;});
            prevY = prevY + 20*(j) + 50;           
            
        });
        
        
        nodes.exit().remove();
}

function connector(d, i){
    return     "M" + 90 + "," + d.source.y
             + "C 70," + d.source.y  //control point 1
             + " 70," + d.target.y //control point 2
        	 + " 90," + d.target.y; // target
}
		 
</script>

</body>
</html>